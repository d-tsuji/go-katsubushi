package katsubushi

import (
	"bufio"
	"bytes"
	"reflect"
	"strings"
	"testing"
)

func TestBResponseBytes(t *testing.T) {
	res := bResponse{
		magic:    0x81,
		opcode:   0x00,
		dataType: 0x00,
		status:   [2]byte{0x00, 0x00},
		opaque:   [4]byte{0x00, 0x00, 0x00, 0x00},
		cas:      [8]byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01},
		extras:   []byte{0xde, 0xad, 0xbe, 0xef},
		key:      "",
		value:    "World",
	}
	actual := res.Bytes()

	expected := []byte{
		0x81, 0x00, 0x00, 0x00,
		0x04, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x09,
		0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x01,
		0xde, 0xad, 0xbe, 0xef,
		0x57, 0x6f, 0x72, 0x6c,
		0x64,
	}

	if bytes.Compare(actual, expected) != 0 {
		t.Errorf("Unextected byte slice: %s", actual)
	}
}

func TestNewBRequest(t *testing.T) {
	{
		input := []byte{
			0x80, 0x02, 0x00, 0x05,
			0x08, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x12,
			0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00,
			0xde, 0xad, 0xbe, 0xef,
			0x00, 0x00, 0x1c, 0x20,
			0x48, 0x65, 0x6c, 0x6c,
			0x6f, 0x57, 0x6f, 0x72,
			0x6c, 0x64,
		}
		br := bytes.NewReader(input)
		req, err := newBRequest(br)

		if err != nil {
			t.Errorf("Failed to parse request: %s", err)
		}

		if req.magic != 0x80 {
			t.Errorf("Unexpected magic: %x", req.magic)
		}

		if req.opcode != 0x02 {
			t.Errorf("Unexpected opcode: %x", req.opcode)
		}

		if req.dataType != 0x00 {
			t.Errorf("Unexpected data type: %x", req.dataType)
		}

		if bytes.Compare(req.vBucket[:], []byte{0x00, 0x00}) != 0 {
			t.Errorf("Unexpected VBucket: %x", req.vBucket)
		}

		if bytes.Compare(req.opaque[:], []byte{0x00, 0x00, 0x00, 0x00}) != 0 {
			t.Errorf("Unexpected opaque: %x", req.opaque)
		}

		if bytes.Compare(req.cas[:], []byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}) != 0 {
			t.Errorf("Unexpected cas: %x", req.cas)
		}

		if bytes.Compare(req.extras, []byte{0xde, 0xad, 0xbe, 0xef, 0x00, 0x00, 0x1c, 0x20}) != 0 {
			t.Errorf("Unexpected extras: %x", req.extras)
		}

		if req.key != "Hello" {
			t.Errorf("Unexpected kes: %s", req.key)
		}

		if req.value != "World" {
			t.Errorf("Unexpected value: %x", req.value)
		}
	}

	{
		input := []byte{
			0x80, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00,
		}
		br := bytes.NewReader(input)
		_, err := newBRequest(br)

		if err == nil {
			t.Error("too short header is not detected")
		}
	}

	{
		input := []byte{
			0x82, 0x00, 0x00, 0x00,
			// extra length = 2
			0x02, 0x00, 0x00, 0x00,
			// total body = 1
			0x00, 0x00, 0x00, 0x02,
			0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00,
			// body = "aa"
			0x61, 0x61,
		}
		br := bytes.NewReader(input)
		_, err := newBRequest(br)

		if err == nil {
			t.Error("length inconsistency is not detected")
		}
	}

	{
		input := []byte{
			0x82, 0x00, 0x00, 0x00,
			// extra length = 2
			0x02, 0x00, 0x00, 0x00,
			// total body = 2
			0x00, 0x00, 0x00, 0x02,
			0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00,
			// body = "a"
			0x61,
		}
		br := bytes.NewReader(input)
		_, err := newBRequest(br)

		if err == nil {
			t.Error("too short body is not detected")
		}
	}

	{
		input := []byte{
			0x80, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00,
			// total body = 2
			0x00, 0x00, 0x00, 0x02,
			0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00,
			// value = "a"
			0x61,
		}
		br := bytes.NewReader(input)
		_, err := newBRequest(br)

		if err == nil {
			t.Error("too short body is not detected")
		}
	}

	{
		input := []byte{
			0x80, 0x00, 0x00, 0x00,
			// extra length = 1
			0x01, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00,
			// total body = 2
			0x00, 0x00, 0x00, 0x01,
			0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00,
			// value = "a"
			0x61,
		}
		br := bytes.NewReader(input)
		_, err := newBRequest(br)

		if err == nil {
			t.Error("too short body is not detected")
		}
	}
}

func TestIsBinaryProtocol(t *testing.T) {
	app := newTestApp(t, nil)

	binCmd := []byte{
		0x80, 0x0b, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00,
	}

	br := bytes.NewReader(binCmd)
	bufBr := bufio.NewReader(br)
	{
		isBin, err := app.IsBinaryProtocol(bufBr)
		if err != nil {
			t.Fatal(err)
		}
		if !isBin {
			t.Errorf("Binary protocol request is regarded as text protocol")
		}
	}

	sr := strings.NewReader("VERSION")
	bufSr := bufio.NewReader(sr)
	{
		isBin, err := app.IsBinaryProtocol(bufSr)
		if err != nil {
			t.Fatal(err)
		}
		if isBin {
			t.Errorf("Text protocol request is regarded as binary protocol")
		}
	}
}

func TestMemdStats_writeBinaryTo(t *testing.T) {
	s := MemdStats{
		Pid:              12,
		Uptime:           134,
		Time:             999999,
		Version:          "v1.5.7",
		CurrConnections:  1023,
		TotalConnections: 12345,
		CmdGet:           5312,
		GetHits:          5311,
		GetMisses:        1,
	}
	w := &bytes.Buffer{}
	s.writeBinaryTo(w, [4]byte{0x00, 0x00, 0x00, 0x00})

	expect := []byte{
		0x81, 0x10, // response Magic, Opcode
		0x00, 0x03, // Key length
		0x00, 0x00, 0x00, 0x00, // Extra Length(1), Data type(1), VBucket(2)
		0x00, 0x00, 0x00, 0x05, // Total body
		0x00, 0x00, 0x00, 0x00, // Opaque
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // CAS
		0x70, 0x69, 0x64, // Key
		0x31, 0x32, // Value
		// Next field
		0x81, 0x10, // response Magic, Opcode
		0x00, 0x06, // Key length
		0x00, 0x00, 0x00, 0x00, // Extra Length(1), Data type(1), VBucket(2)
		0x00, 0x00, 0x00, 0x09, // Total Body
		0x00, 0x00, 0x00, 0x00, // Opaque
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // CAS
		0x75, 0x70, 0x74, 0x69, 0x6d, 0x65, // Key
		0x31, 0x33, 0x34, // Value
		// Next field
		0x81, 0x10, // response Magic, Opcode
		0x00, 0x04, // Key length
		0x00, 0x00, 0x00, 0x00, // Extra Length(1), Data type(1), VBucket(2)
		0x00, 0x00, 0x00, 0x0a, // Total Body
		0x00, 0x00, 0x00, 0x00, // Opaque
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // CAS
		0x74, 0x69, 0x6d, 0x65, // Key
		0x39, 0x39, 0x39, 0x39, 0x39, 0x39, // Value
		// Next field
		0x81, 0x10, // response Magic, Opcode
		0x00, 0x07, // Key length
		0x00, 0x00, 0x00, 0x00, // Extra Length(1), Data type(1), VBucket(2)
		0x00, 0x00, 0x00, 0x0d, // Total Body
		0x00, 0x00, 0x00, 0x00, // Opaque
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // CAS
		0x76, 0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e, // Key
		0x76, 0x31, 0x2e, 0x35, 0x2e, 0x37, // Value
		// Next field
		0x81, 0x10, // response Magic, Opcode
		0x00, 0x10, // Key length
		0x00, 0x00, 0x00, 0x00, // Extra Length(1), Data type(1), VBucket(2)
		0x00, 0x00, 0x00, 0x14, // Total body
		0x00, 0x00, 0x00, 0x00, // Opaque
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // CAS
		0x63, 0x75, 0x72, 0x72, 0x5f, 0x63, 0x6f, 0x6e, 0x6e, 0x65, // Key
		0x63, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x31, 0x30, 0x32, 0x33, // Value
		// Next field
		0x81, 0x10, // response Magic, Opcode
		0x00, 0x11, // Key length
		0x00, 0x00, 0x00, 0x00, // Extra Length(1), Data type(1), VBucket(2)
		0x00, 0x00, 0x00, 0x16, // Total body
		0x00, 0x00, 0x00, 0x00, // Opaque
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // CAS
		0x74, 0x6f, 0x74, 0x61, 0x6c, 0x5f, 0x63, 0x6f, 0x6e, 0x6e, 0x65, // Key
		0x63, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x31, 0x32, 0x33, 0x34, 0x35, // Value
		// Next field
		0x81, 0x10, // respones Magic, Opcode
		0x00, 0x07, // Key length
		0x00, 0x00, 0x00, 0x00, // Extra Length(1), Data type(1), VBucket(2)
		0x00, 0x00, 0x00, 0x0b, // Total body
		0x00, 0x00, 0x00, 0x00, // Opaque
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // CAS
		0x63, 0x6d, 0x64, 0x5f, 0x67, 0x65, 0x74, // Key
		0x35, 0x33, 0x31, 0x32, // Value
		// Next field
		0x81, 0x10, // response Mgic, Opcode
		0x00, 0x08, // Key length
		0x00, 0x00, 0x00, 0x00, // Extra Length(1), Data type(1), VBucket(2)
		0x00, 0x00, 0x00, 0x0c, // Total body
		0x00, 0x00, 0x00, 0x00, // Opaque
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // CAS
		0x67, 0x65, 0x74, 0x5f, 0x68, 0x69, 0x74, 0x73, // Key
		0x35, 0x33, 0x31, 0x31, // Value
		// Next field
		0x81, 0x10, // response Magic, Opcode
		0x00, 0x0a, // Key length
		0x00, 0x00, 0x00, 0x00, // Extra Length(1), Data type(1), VBucket(2)
		0x00, 0x00, 0x00, 0x0b, // Total body
		0x00, 0x00, 0x00, 0x00, // Opaque
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // CAS
		0x67, 0x65, 0x74, 0x5f, 0x6d, 0x69, 0x73, 0x73, 0x65, 0x73, // Key
		0x31, // Value
		// Last empty field
		0x81, 0x10, // response Magic, Opcode
		0x00, 0x00, // Key length
		0x00, 0x00, 0x00, 0x00, // Extra Length(1), Data type(1), VBucket(2)
		0x00, 0x00, 0x00, 0x00, // Total body
		0x00, 0x00, 0x00, 0x00, // Opaque
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // CAS
	}
	if g, e := w.Bytes(), expect; !reflect.DeepEqual(g, e) {
		t.Errorf("got: \n%#v,\nexpect: %#v\n", g, e)
	}
}
